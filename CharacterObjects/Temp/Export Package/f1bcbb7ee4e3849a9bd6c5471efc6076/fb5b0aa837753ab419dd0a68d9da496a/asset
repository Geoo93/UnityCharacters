using UnityEngine;
using System.Collections;

[ExecuteInEditMode] 
public class FishController : MonoBehaviour {
	
	public float minSwimSpeed;
	public float maxSwimSpeed;
	public float TurnDelta;
	public float minWaypointTime;
	public float maxWaypointTime;
	public float minWayPointSwitchDistance;
	public Vector3 SwimBounds;
	public float FleeSpeed;
	public float FleeTurnBoost = 10;
	public Transform FleeTarget;
	public Animation Ani;
	
	private float swimSpeed, turnSpeed,  maxPathPointTime, nextWayPointTime;
	private Vector3 BaseOrigin;
	private Vector3 ActiveWayPoint;
	private Quaternion targetRotation;
	private int maxFleeCycles = 24;
	private bool FLEE;
	private AnimationState animationState;

	void Start () {
		swimSpeed = Random.Range(minSwimSpeed,maxSwimSpeed);
		turnSpeed = Random.Range(swimSpeed,maxSwimSpeed) / TurnDelta;
		maxPathPointTime = Random.Range(minWaypointTime,maxWaypointTime);
		nextWayPointTime = Time.time + maxPathPointTime;
		BaseOrigin = transform.position;
		SetNextWayPoint();
		animationState = Ani["Take 001"];
	}
	
	void SetNextWayPoint() {
		ActiveWayPoint.x = BaseOrigin.x + Random.Range(-SwimBounds.x,SwimBounds.x);
		ActiveWayPoint.y = BaseOrigin.y + Random.Range(-SwimBounds.y,SwimBounds.y);
		ActiveWayPoint.z = BaseOrigin.z + Random.Range(-SwimBounds.z,SwimBounds.z);
	}
	
	void Update () {
		
		if (!Application.isPlaying) {
			BaseOrigin = transform.position;
			DrawBounds();
			return;
		}
		
		if( Time.time > nextWayPointTime || Vector3.Distance(ActiveWayPoint, transform.position) <= minWayPointSwitchDistance ) {
			swimSpeed = Random.Range(minSwimSpeed,maxSwimSpeed);
			turnSpeed = Random.Range(swimSpeed,maxSwimSpeed) / TurnDelta;
			maxPathPointTime = Random.Range(minWaypointTime,maxWaypointTime);
			nextWayPointTime = Time.time + maxPathPointTime;
			SetNextWayPoint();
			if(FLEE)
				FLEE = false;
		}
		
		if(!FLEE) {
			if(Vector3.Distance(transform.position, FleeTarget.position) < 3.0f) {
				int counter = 0;
				for (int i=0;i<maxFleeCycles;i++) {
					SetNextWayPoint();
					Vector3 ToTargetDir = FleeTarget.position - transform.position;
					Vector3 WayPointDir = ActiveWayPoint - transform.position;
					if(Vector3.Dot(ToTargetDir, WayPointDir) < 0.0f) {
						FLEE = true;
						break;
					}
					counter++;
				}
			}
		}
			
		Vector3 lookDirection = ActiveWayPoint - transform.position;
    	Quaternion rot = Quaternion.LookRotation(lookDirection.normalized);
		
		if(FLEE)
			animationState.speed = 6.0f;
		else
			animationState.speed = 1 * swimSpeed;
		
		if(!FLEE) {
			transform.rotation = Quaternion.RotateTowards(transform.rotation, rot, turnSpeed * Time.deltaTime);
			transform.Translate(Vector3.forward * swimSpeed * Time.deltaTime);
		} else {
			float FleeTurnSpeed = turnSpeed * FleeTurnBoost;
			transform.rotation = Quaternion.RotateTowards(transform.rotation, rot, FleeTurnSpeed * Time.deltaTime);
			transform.Translate(Vector3.forward * FleeSpeed * Time.deltaTime);
		}

	}
	
	void DrawBounds() {
		Debug.DrawLine(BaseOrigin + new Vector3(-SwimBounds.x,-SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(-SwimBounds.x,-SwimBounds.y,SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(-SwimBounds.x,-SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(SwimBounds.x,-SwimBounds.y,-SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(SwimBounds.x,-SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(SwimBounds.x,-SwimBounds.y,SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(SwimBounds.x,-SwimBounds.y,SwimBounds.z), BaseOrigin + new Vector3(-SwimBounds.x,-SwimBounds.y,SwimBounds.z), Color.red);
		
		Debug.DrawLine(BaseOrigin + new Vector3(-SwimBounds.x,SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(-SwimBounds.x,SwimBounds.y,SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(-SwimBounds.x,SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(SwimBounds.x,SwimBounds.y,-SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(SwimBounds.x,SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(SwimBounds.x,SwimBounds.y,SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(SwimBounds.x,SwimBounds.y,SwimBounds.z), BaseOrigin + new Vector3(-SwimBounds.x,SwimBounds.y,SwimBounds.z), Color.red);
		
		Debug.DrawLine(BaseOrigin + new Vector3(-SwimBounds.x,-SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(-SwimBounds.x,SwimBounds.y,-SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(-SwimBounds.x,-SwimBounds.y,SwimBounds.z), BaseOrigin + new Vector3(-SwimBounds.x,SwimBounds.y,SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(SwimBounds.x,-SwimBounds.y,-SwimBounds.z), BaseOrigin + new Vector3(SwimBounds.x,SwimBounds.y,-SwimBounds.z), Color.red);
		Debug.DrawLine(BaseOrigin + new Vector3(SwimBounds.x,-SwimBounds.y,SwimBounds.z), BaseOrigin + new Vector3(SwimBounds.x,SwimBounds.y,SwimBounds.z), Color.red);
	}
	
}